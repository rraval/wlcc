module Assembler.Tests(main) where

import Control.Monad(liftM, liftM2, liftM3)
import qualified Data.Map as M
import Data.Word(Word16, Word32)
import Test.QuickCheck
import Text.ParserCombinators.Parsec(runParser)

import Assembler.Data
import Assembler.Parser(parser)

instance Arbitrary Register where
    arbitrary = arbitraryBoundedIntegral

instance Arbitrary Word16 where
    arbitrary = arbitraryBoundedIntegral

instance Arbitrary Word32 where
    arbitrary = arbitraryBoundedIntegral

instance Arbitrary Operation where
    arbitrary = oneof
        [ liftM3 Add arbitrary arbitrary arbitrary
        , liftM3 Beq arbitrary arbitrary arbitrary
        , liftM3 Bne arbitrary arbitrary arbitrary
        , liftM2 Div arbitrary arbitrary
        , liftM2 Divu arbitrary arbitrary
        , liftM Jalr arbitrary
        , liftM Jr arbitrary
        , liftM Lis arbitrary
        , liftM3 Lw arbitrary arbitrary arbitrary
        , liftM Mfhi arbitrary
        , liftM Mflo arbitrary
        , liftM2 Mult arbitrary arbitrary
        , liftM2 Multu arbitrary arbitrary
        , liftM3 Slt arbitrary arbitrary arbitrary
        , liftM3 Sltu arbitrary arbitrary arbitrary
        , liftM3 Sub arbitrary arbitrary arbitrary
        , liftM3 Sw arbitrary arbitrary arbitrary
        , liftM Word arbitrary
        ]

-- Can't use Label because that's exported by Assembler.Data
-- QC prefix is for "QuickCheck", aren't I clever?
newtype QCLabel = QCLabel String
instance Arbitrary QCLabel where
    arbitrary = liftM QCLabel $ listOf1 $ elements $ ['A'..'Z'] ++ ['a'..'z']
instance Show QCLabel where
    show (QCLabel s) = s

newtype Whitespace = Whitespace String
instance Arbitrary Whitespace where
    arbitrary = oneof
        [ liftM Whitespace $ listOf1 $ elements $ [' ', '\t', '\f', '\v', '\n']
        , do
            content <- arbitrary :: Gen String
            return $ Whitespace $ ';' : filter (/= '\n') content ++ "\n"
        ]

instance Show Whitespace where
    show (Whitespace s) = s

instance Arbitrary Metadata where
    arbitrary = do
        -- figure out number of operations after the parse
        numops <- suchThat (arbitrary :: Gen Integer) (>=0)
        -- generate a whole bunch of labels and pick a location for it's definition
        -- labels :: (QCLabel, Integer)
        labels <- listOf1 $ liftM2 (,) (liftM show (arbitrary :: Gen QCLabel)) $ choose (0, numops)
        return $ Metadata (M.fromList labels) numops

data Program = Program
    { expected      :: [Operation]  -- ^ expected result from parsing 'source'
    , source        :: String       -- ^ randomly generated source text corresponding to 'expected' parse
    , metadata      :: Metadata     -- ^ information about 'expected' that should accompany parser results
    } deriving (Show)

instance Arbitrary Program where
    arbitrary = do
        meta <- (arbitrary :: Gen Metadata)
        let labels = labelTable meta
        -- lines :: M.Map (Integer, [Label]), i.e. just flip around labels and locations
            flipLabelTable label location = M.insertWith (++) location [label]
            lines = M.foldWithKey flipLabelTable M.empty labels
        -- (wordOffset meta) is the required number of operations
        -- nolabelsource :: [(Operation, String)]
        -- Each element of nolabelsource contains the expected operation after parsing and the corresponding
        -- source text. However, this source does not yet include label definitions (since we don't know
        -- operation offsets yet).
        nolabelsource <- vectorOf (fromIntegral (wordOffset meta)) $ oneof $ operations labels
        -- generate the labels at the end of the file (not generated by the foldr below)
        lastlabels <- labelsForLine lines $ wordOffset meta
        -- Add label definitions to the nolabelsource and flatten it all as one string.
        (ops, src) <- foldr (generateLabels lines) (return ([], lastlabels)) $ zip [0..] nolabelsource
        return $ Program ops src meta
      where operations :: M.Map String Integer -> [Gen (Operation, String)]
            operations labels = [ register3           Add     "add"
                                , branch              Beq     "beq"
                                , branchLabel labels  BeqL    "beq"
                                , branch              Bne     "bne"
                                , branchLabel labels  BneL    "bne"
                                , register2           Div     "div"
                                , register2           Divu    "divu"
                                , register            Jalr    "jalr"
                                , register            Jr      "jr"
                                , register            Lis     "lis"
                                , memory              Lw      "lw"
                                , register            Mfhi    "mfhi"
                                , register            Mflo    "mflo"
                                , register2           Mult    "mult"
                                , register2           Multu   "multu"
                                , register3           Slt     "slt"
                                , register3           Sltu    "sltu"
                                , register3           Sub     "sub"
                                , memory              Sw      "sw"
                                , do -- Word
                                    instr <- pad ".word"
                                    word <- (arbitrary :: Gen MipsWord)
                                    return $ (Word word, instr ++ show word)
                                ]

            generateLabels ::   M.Map Integer [Label] ->
                                (Integer, (Operation, String)) ->
                                Gen ([Operation], String) ->
                                Gen ([Operation], String)
            generateLabels lines (offset, (op, instr)) gen = do
                (ops, src) <- gen
                let newop = case op of
                        (BeqL s t l o) -> BeqL s t l offset
                        (BneL s t l o) -> BneL s t l offset
                        _ -> op

                case M.lookup offset lines of
                    Nothing -> return (newop : ops, instr ++ src)
                    Just ls -> do
                        labelsrc <- labelsForLine lines offset
                        return $ (newop : ops, labelsrc ++ instr ++ src)

            labelsForLine :: M.Map Integer [Label] -> Integer -> Gen String
            labelsForLine lines offset = do
                -- see if we have labels defined for this offset
                case M.lookup offset lines of
                    Nothing -> pad $ "" -- put in some whitespace for kicks
                    -- add a colon to every label and pad with whitespace, then flatten the list
                    -- to a single string
                    Just ls -> foldr1 (liftM2 (++)) $ map (pad . (++ ":")) ls

            pad s = do
                init <- arbitrary :: Gen Whitespace
                end <- arbitrary :: Gen Whitespace
                return $ show init ++ s ++ show end
            padR r = pad $ '$' : show r

            --register :: (Register -> a) -> String -> Gen a
            register cons str = do
                instr <- pad str
                reg <- arbitrary :: Gen Register
                regstr <- padR reg
                return $ (cons reg, instr ++ regstr)
            registern regn_1 c str = do   -- piggy backs on register(n - 1) to provide registern
                (cons, instr) <- regn_1 c str
                comma <- pad ","
                reg <- arbitrary :: Gen Register
                regstr <- padR reg
                return $ (cons reg, instr ++ comma ++ regstr)
            register2 = registern register
            register3 = registern register2

            branch :: (Register -> Register -> Offset -> Operation) -> String -> Gen (Operation, String)
            branch c str = do
                (cons, instr) <- register2 c str
                comma <- pad ","
                offset <- arbitrary :: Gen Offset
                offstr <- pad $ show offset
                return $ (cons offset, instr ++ comma ++ offstr)

            branchLabel ::  (M.Map String Integer) ->
                            (Register -> Register -> Label -> Integer -> Operation) ->
                            String ->
                            Gen (Operation, String)
            branchLabel labels c str = do
                (cons, instr) <- register2 c str
                comma <- pad ","
                index <- choose (0, M.size labels - 1)
                let (label, _) = M.elemAt index labels
                labelpadded <- pad label
                -- note that we're setting the offset here as 0
                -- this'll be fixed in the generateLabels step
                return $ (cons label 0, instr ++ comma ++ labelpadded)

            memory :: (Register -> Offset -> Register -> Operation) -> String -> Gen (Operation, String)
            memory c str = do
                (cons, instr) <- register c str
                comma <- pad ","
                offset <- arbitrary :: Gen Offset
                offstr <- pad $ show offset
                lparen <- pad "("
                reg <- arbitrary :: Gen Register
                regstr <- padR reg
                rparen <- pad ")"
                return $ (cons offset reg, instr ++ comma ++ offstr ++ lparen ++ regstr ++ rparen)

-- default Metadata for use in tests
emptyMetadata = Metadata M.empty 0

parseProgram :: Program -> Bool
parseProgram p = case runParser parser emptyMetadata "" $ source p of
    Right (meta, ops)    -> ops == expected p && meta == metadata p
    Left err            -> error $ show err

main = quickCheck $ label "Complete Program" parseProgram

